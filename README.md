## Team number, member names, and x500.
- Team number: Team-010-70
- Member names and x500: Jeffrey Hu (hu000557), Anas Mohamed (moha1325)

## What is the project about (overview of the whole project, not just the hw4)?
This project is a 3D simulation of a system for delivering packages with the use of drones in the UMN campus area.

The simulation provides features such as camera movement (e.g. focusing the camera on an entity), simulation speed adjustment, and route visualization.

The simulation allows package generation, automatically scheduling the packages/deliveries once a package and corresponding robot owner is created. The scheduling page provides a variety of customization, including choosing a routing algorithm and other features described in the “What does the simulation do specifically?” section. The simulation then simulates how drones move to, pick up, and deliver these packages.

Throughout the course, multiple features were added to this system using several design patterns, including the addition of celebrations with the decorator design pattern, different routing algorithms for movement with the strategy design pattern, additional entities like helicopters and humans, and notifications for delivery events with the observer design pattern. Additionally, the mechanism for generating entities was refactored to be more efficient with the composite design pattern. Again, these features are described in more detail in the “What does the simulation do specifically?” section.

## How to run the simulation (overview of the whole project, not just the hw4)?
The docker file can be run with
```shell
docker run --rm -it -p 8081:8081 jhu04/team-010-70-hw4
```

---

The simulation can also be run (on Ubuntu) with the source code by first compiling with
```shell
make -j
```
then running the simulation with
```shell
make run
```

## What does the simulation do specifically (individual features i.e. movement of entities etc) (overview of the whole project, not just the hw4)?
When the simulation is first run, a drone will be generated by default, along with a human and a helicopter.

The actual scheduling of packages is then done with the use of a scheduling page. Upon choosing a name, start point/destination (by picking two points from a 2D bird’s eye view of the map), and routing algorithm, a package will be scheduled with the click of a button and added to a queue of deliveries.

Once the package is scheduled, it will be generated at the given start point, upon which a drone will automatically go over to it in a straight line (if the package is at the front of the queue). Using the routing algorithm the package was scheduled with (A*, breadth-first search, depth-first search, or Dijkstra), the drone will first go to the package and then deliver the package to the robot. This process can be watched in slow or fast motion by changing the simulation speed.

Upon successful delivery, the drone will complete a celebration based on the routing algorithm that was used, such as jumping up and down or spinning. As a specific example, the drone will spin for some time, then jump for some time after completing an order using Dijkstra’s.

It will then repeat these actions for the rest of the packages in the delivery queue.

Finally, there are also additional entities such as helicopters and humans for realism. Helicopters repeatedly choose random destination points and travel to their destination using a beeline strategy, while humans choose random destinations and travel using A*. Additional humans can be added from the scheduling page.

# New Feature
## What does it do?
The new feature generates notifications (in the notification bar on the left side of the window) for each step in the delivery of a package. Specifically, it generates 3 distinct notifications for the drone completing the delivery and 2 notifications for the package being delivered. For the drone, this includes picking the package up, starting the process of delivering it, and confirming the dropoff was completed. For the package, this includes the package being scheduled and the delivery being completed.

## Why is it significantly interesting?
The use of a notification system adds enhanced visibility to the simulation. Before the addition of this feature, it would be difficult to keep track of things like the status of specific packages, especially in situations where there were many packages. Perhaps a simulation including one or two packages can have deliveries tracked easily, but it could get more complicated with the inclusion of 100 packages instead. The notification system gives a simple way to track specific packages, regardless of the volume.

Related, notifications could help track drones for administrative purposes. With some additional extensions/additional text processing, notifications could also be filtered to let customers know the state of their package.

## How does it add to the existing work?
It adds to the existing simulation model through its interaction with the entities that were already present. The notification system works by checking the status of the entities and sending updates if the entity's status has changed or fulfilled a certain condition.  It also enhances the communication aspect of the system. Before this feature was implemented, the communication between the system and the user basically came down to just observing the entities moving on the map. Now, with the notification system implemented, the communication of the system was added to, as updates give another avenue for users to get information about the simulation.

## Which design pattern did you choose to implement it and why?
The observer design pattern was chosen for this feature. The “subscribe” mechanism was suited here, as the observers would “subscribe” to the specific entities, and be notified by them when an event occurred. Additionally, the use of the design pattern provided benefits such as loose coupling and higher extensibility. Although the notifications could have just been implemented directly in the entity classes, by using the observer pattern other entities can now have the subscriber mechanism added to them quickly due to the structure that was provided.

## Instruction to use this new feature (if the new feature is not user interactable, please mention this as well)
Upon starting the simulation, navigate to the scheduling page and schedule 1 or more packages for delivery. Then, navigate back to the simulation itself. At this point, no more user input should be needed. As the drone is delivering the packages, the notification bar on the left side of the screen should be displaying update messages.

## Sprint retrospective
The goal of the 2 sprints was to implement a notification feature in the drone simulation. This goal was successfully achieved by the end of sprint 2.

Something that went well was how we implemented the separate observers. We first implemented the IObserver and DroneObserver, and we built the PackageObserver based on it once it was functional. Doing it this way made debugging and adding features (such as front-end integration) easier to do for both the DroneObserver and PackageObserver.

While we generally followed most of the issues in our backlog, we didn’t 100% exactly follow the issues in the exact order we planned in our sprint planning. For example, we completed the observer classes and front-end integration around the same time, when in our sprint planning meeting it was decided that the front-end integration would happen in sprint 2 and the observers would be completed in sprint 1. In general, the timing planned for the sprints was not too accurate.

## Docker
For the Docker file, find the Docker repository at https://hub.docker.com/repository/docker/jhu04/team-010-70-hw4/general

## Youtube Video Link
For the presentation slides, see the slides PDF in the project GitHub as `presentation.pdf`. Alternatively, see the slides at this shared link: https://docs.google.com/presentation/u/3/d/151bu3P2SQ0YUPv2_7oGYsWaxh5n7HJendNQAi8dKeLQ/edit?usp=sharing

Youtube Video (Drone simulation with observers feature explanation and demo): https://youtu.be/8pDLK7YACDg

## UML Diagram
For the UML Diagram, see the image below. Alternatively, see file in the project GitHub as `uml.pdf`. Alternatively again, see a LucidChart link containing the diagram at https://lucid.app/lucidchart/3327ab31-1eed-4570-b61e-535b0ad5f6af/edit?viewport_loc=-1191%2C-241%2C1782%2C1688%2C0_0&invitationId=inv_3d07f0c9-5985-4505-abc8-608b693b3523
![UML](uml.png)